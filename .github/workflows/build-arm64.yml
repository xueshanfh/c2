name: Build Fully Static ARM64 FastIO (musl)

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]

jobs:
  build-musl-static:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up QEMU for ARM64
      uses: docker/setup-qemu-action@v3
      with:
        platforms: arm64
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Create Musl Static Build Dockerfile
      run: |
        cat > Dockerfile.musl << 'EOF'
        # Use Alpine Linux with musl libc for truly static builds
        FROM arm64v8/alpine:3.18
        
        # Install musl development tools
        RUN apk add --no-cache \
            build-base \
            musl-dev \
            linux-headers \
            file
        
        # Download Lua 5.3 headers for compilation (headers only)
        RUN mkdir -p /usr/local/include/lua && \
            cd /tmp && \
            wget https://www.lua.org/ftp/lua-5.3.6.tar.gz && \
            tar -xzf lua-5.3.6.tar.gz && \
            cp lua-5.3.6/src/lua.h \
               lua-5.3.6/src/luaconf.h \
               lua-5.3.6/src/lauxlib.h \
               lua-5.3.6/src/lualib.h \
               /usr/local/include/lua/ && \
            rm -rf lua-5.3.6*
        
        WORKDIR /build
        COPY fastio_embedded.c .
        
        # Create version with explicit malloc/free includes
        RUN cat > fastio_static.c << 'CEOF'
        #include <stdio.h>
        #include <stdlib.h>
        #include <errno.h>
        #include <string.h>
        #include <lua.h>
        #include <lauxlib.h>
        
        #define CHUNK_SIZE (1024 * 1024)
        
        // Completely static read_chunk function
        static int read_chunk(lua_State *L) {
            const char *path = luaL_checkstring(L, 1);
            FILE *fp = fopen(path, "rb");
            if (!fp) {
                luaL_error(L, "cannot open %s: %s", path, strerror(errno));
                return 0;
            }
        
            char *buf = (char*)malloc(CHUNK_SIZE);
            if (!buf) {
                fclose(fp);
                luaL_error(L, "memory allocation failed");
                return 0;
            }
            
            luaL_Buffer b;
            luaL_buffinit(L, &b);
            size_t nread;
        
            while ((nread = fread(buf, 1, CHUNK_SIZE, fp)) > 0) {
                luaL_addlstring(&b, buf, nread);
            }
        
            free(buf);
            
            if (ferror(fp)) {
                fclose(fp);
                luaL_error(L, "read error for %s", path);
                return 0;
            }
            fclose(fp);
            
            luaL_pushresult(&b);
            return 1;
        }
        
        static const luaL_Reg fastio_lib[] = {
            {"read_chunk", read_chunk},
            {NULL, NULL}
        };
        
        // Static export for embedded environments
        __attribute__((visibility("default"))) int luaopen_fastio(lua_State *L) {
            luaL_newlib(L, fastio_lib);
            return 1;
        }
        CEOF
        
        # Build completely static binary with musl
        RUN gcc -static -O3 -fPIC -Wall -Wextra -std=c99 \
            -DLUA_COMPAT_5_3 -DLUA_USE_LINUX -DLUA_VERSION_NUM=503 \
            -march=armv8-a -mtune=cortex-a72 \
            -DNDEBUG -fstack-protector \
            -I/usr/local/include/lua \
            -c fastio_static.c -o fastio.o
        
        # Link as shared library but with static libc
        RUN gcc -shared -static-libgcc -fPIC \
            -Wl,-soname,fastio.so \
            -Wl,--as-needed \
            -o fastio.so fastio.o
        
        # Also try completely static approach
        RUN gcc -static -O3 -fPIC -Wall -Wextra -std=c99 \
            -DLUA_COMPAT_5_3 -DLUA_USE_LINUX -DLUA_VERSION_NUM=503 \
            -march=armv8-a -mtune=cortex-a72 \
            -DNDEBUG -fstack-protector \
            -I/usr/local/include/lua \
            fastio_static.c -shared -o fastio_full_static.so
        
        # Verify builds
        RUN echo "=== Static ARM64 FastIO Builds ===" && \
            file fastio.so && \
            file fastio_full_static.so && \
            ls -la fastio*.so && \
            echo "=== Dependencies Check ===" && \
            (ldd fastio.so 2>/dev/null || echo "✓ Fully static - no dependencies") && \
            (ldd fastio_full_static.so 2>/dev/null || echo "✓ Fully static - no dependencies")
        
        CMD ["tail", "-f", "/dev/null"]
        EOF
    
    - name: Build Static ARM64 FastIO
      run: |
        echo "Building fully static ARM64 FastIO..."
        
        docker buildx build --platform linux/arm64 \
          -f Dockerfile.musl \
          -t fastio-musl-static:latest \
          --load \
          .
        
        mkdir -p output
        
        # Extract both static versions
        docker run --rm --platform linux/arm64 \
          -v $PWD/output:/output \
          fastio-musl-static:latest \
          sh -c "cp /build/fastio.so /output/fastio_static.so && cp /build/fastio_full_static.so /output/"
        
        echo "=== Static Build Results ==="
        ls -la output/
        file output/*.so
        
        echo "✓ Fully static ARM64 binaries ready"
    
    - name: Upload Static ARM64 binaries
      uses: actions/upload-artifact@v4
      with:
        name: fastio-fully-static-arm64
        path: output/*.so
        retention-days: 90
